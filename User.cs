/* This file is part of the Druware.Client API Library
 *
 * The Druware.Client API Library is free software: you can redistribute it
 * and/or modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 3 of the License,
 * or (at your option) any later version.
 *
 * The Druware.Client API Library is distributed in the hope that it will be
 * useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
 * Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * the Druware.Client API Library. If not, see <https://www.gnu.org/licenses/>.
 *
 * Copyright 2019-2023 by:
 *    Satori & Associates, Inc.
 *    All Rights Reserved
 ******************************************************************************/

/* History
 *   Modified By  How
 *   -------- --- --------------------------------------------------------------
 *   23/10/25 ars Added documentation and license header, cleaned up all code to
 *                remove extraneous code and verbosity
 ******************************************************************************/

using System.Text.Json.Serialization;
using RESTfulFoundation;

namespace Druware.Client;

/// <summary>
/// the User entity represents a single user in the system and while the Profile
/// wrapper consumes the same object, it ONLY works for the current user, while
/// the User entity can be used with any user in the system, assuming the logged
/// in user has sufficient rights to do so.
/// </summary>
public partial class User : RESTObject
{
    /// <summary>
    /// the path to this endpoint
    /// </summary>
    public const string Path = "/api/user/";

    /// <summary>
    /// default constructor required to support the Json interfaces for
    /// deserialization
    /// </summary>
    public User()
    {
    }
    
    /// <summary>
    /// the First Name of the user ( friendly )
    /// </summary>
    [JsonPropertyName("firstName")] public string? FirstName { get; set; }
    
    /// <summary>
    /// the Last Name/ Surname of the user
    /// </summary>
    [JsonPropertyName("lastName")] public string? LastName { get; set; }

    /// <summary>
    /// the date and time the user account was initially registered. Though the
    /// entity will allow this value to be set for serialization, it is never
    /// written by the object.
    /// </summary>
    [JsonPropertyName("registered")] 
    public DateTime? Registered { get; set; }
    
    /// <summary>
    /// the date and time that the current session expires. this value should be
    /// reset and refreshed as it is accessed, and expires after a predetermined
    /// amount of idle time between accesses.
    /// </summary>
    [JsonPropertyName("sessionExpires")]
    public DateTime? SessionExpires { get; set; }
    
    /// <summary>
    /// the internal Id of the user.  This is read only and is auto generated by
    /// the engine at the time of initial registration.
    /// </summary>
    [JsonPropertyName("id")] 
    public string? Id { get; set; }

    [JsonPropertyName("userName")] 
    public string? UserName { get;  set; }

    [JsonPropertyName("normalizedUserName")]
    public string? NormalizedUserName { get; set; }

    [JsonPropertyName("email")] public string? Email { get; set; }

    [JsonPropertyName("emailConfirmed")]
    public bool EmailConfirmed { get; set; } = false;

    [JsonPropertyName("phoneNumber")] public string? PhoneNumber { get; set; }

    [JsonPropertyName("phoneNumberConfirmed")]
    public bool PhoneNumberConfirmed { get;  set; } = false;

    [JsonPropertyName("twoFactorEnabled")]
    public bool TwoFactorEnabled { get;  set; } = false;

    [JsonPropertyName("lockoutEnd")] public DateTime? LockoutEnd { get; set; }

    [JsonPropertyName("lockoutEnabled")]
    public bool LockoutEnabled { get; set; } = false;

    [JsonPropertyName("accessFailedCount")]
    public short AccessFailedCount { get; set; } = 0;
}

/// <summary>
/// additional implementation methods for ease of access and usage.
/// </summary>
public partial class User
{
    public static async Task<User?> Get(
        RESTConnection connection,
        string id,
        Action<User?>? completion = null,
        Action<string?>? failure = null)
    {
        var result = await connection.GetAsync(User.Path, id,
            null,
            (User? r) => { completion?.Invoke(r); },
            (string? message) => { failure?.Invoke(message); });
        return result;
    }

    public async Task<User?> Save(
        RESTConnection connection,
        Action<User?>? completion = null,
        Action<string?>? failure = null)
    {
        var result = await connection.PutAsync(
            User.Path,
            "",
            this,
            (User? r) => completion?.Invoke(r),
            (string? message) => failure?.Invoke(message)
        );
        return result;
    }
    
    // LIST

    public static async Task<RESTObjectList<User>?> ListAsync(
        RESTConnection connection,
        int page = 0, int perPage = 100,
        Action<RESTObjectList<User>?>? completion = null,
        Action<string?>? failure = null)
    {
        var result = await connection.ListAsync(
            User.Path, page, perPage,
            "",
            (RESTObjectList<User>? r) => { completion?.Invoke(r); },
            (string? message) => { failure?.Invoke(message); });
        return result;
    }

    public static RESTObjectList<User> List(
        RESTConnection connection,
        int page = 0, int perPage = 100)
    {
        var result = connection.List<User>(User.Path, page, perPage, "");
        return result;
    }

    public static async Task<bool> LogoutAsync(
        RESTConnection connection,
        Action<bool>? completion = null,
        Action<string?>? failure = null)
    {
        var result = await connection!.DeleteAsync(Login.Path, "", (bool r) =>
            {
                completion?.Invoke(r);
            },
            (string? message) => {
                failure?.Invoke(message);
            });
        return result;
    }
    
    public static bool Logout(
        RESTConnection connection)
    {
        var result = connection!.Delete(Login.Path, "");
        return result;
    }
    
    
}
    